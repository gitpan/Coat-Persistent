.\" Automatically generated by Pod::Man 2.1801 (Pod::Simple 3.05)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Coat::Persistent 3"
.TH Coat::Persistent 3 "2009-09-17" "perl v5.10.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Coat::Persistent \-\- Simple Object\-Relational mapping for Coat objects
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Coat::Persistent is an object to relational-databases mapper, it allows you to
build instances of Coat objects and save them into a database transparently.
.PP
You basically define a mapping rule, either global or per-class and play with
your Coat objects without bothering with \s-1SQL\s0 for simple cases (selecting,
inserting, updating).
.PP
Coat::Peristent lets you use \s-1SQL\s0 if you want to, considering \s-1SQL\s0 is the best
language when dealing with compelx queries.
.SH "WHY THIS MODULE ?"
.IX Header "WHY THIS MODULE ?"
There are already very good ORMs for Perl available in the \s-1CPAN\s0 so why did this
module get added?
.PP
Basically for one reason: I wanted a very simple way to build persistent
objects for Coat and wanted something near the smart design of Rails'\s-1ORM\s0
(ActiveRecord). Moreover I wanted my \s-1ORM\s0 to let me send \s-1SQL\s0 requests if I
wanted to (so I can do basic actions without \s-1SQL\s0 and complex queries with \s-1SQL\s0).
.PP
This module is the result of my experiments of mixing \s-1DBI\s0 and Coat together,
although it is a developer release, it works pretty well and fit my needs.
.PP
This module is expected to change in the future (don't consider the \s-1API\s0 to be
stable at this time), and to grow (hopefully).
.PP
The underlying target of this module is to port the whole ActiveRecord::Base
\&\s-1API\s0 to Perl. If you find the challenge and the idea interesting, feel free to 
contact me for giving a hand.
.PP
This is still a development version and should not be used in production
environment.
.SH "DATA BACKEND"
.IX Header "DATA BACKEND"
The concept behing this module is the same behind the \s-1ORM\s0 of Rails : there are
conventions that tell how to translate a model meta-information into a \s-1SQL\s0
one :
.PP
The conventions implemented in Coat::Persistent are the following:
.IP "The primary key of the tables mapped should be named 'id'." 4
.IX Item "The primary key of the tables mapped should be named 'id'."
.PD 0
.ie n .IP "Your table names must be named like the package they map, with the following rules applied : lower case, replace ""::"" by ""_"". For instance a class Foo::Bar should be mapped to a table named ""foo_bar""." 4
.el .IP "Your table names must be named like the package they map, with the following rules applied : lower case, replace ``::'' by ``_''. For instance a class Foo::Bar should be mapped to a table named ``foo_bar''." 4
.IX Item "Your table names must be named like the package they map, with the following rules applied : lower case, replace :: by _. For instance a class Foo::Bar should be mapped to a table named foo_bar."
.ie n .IP "All foreign keys must be named ""<table>_id"" where table is the name if the class mapped formated like said above." 4
.el .IP "All foreign keys must be named ``<table>_id'' where table is the name if the class mapped formated like said above." 4
.IX Item "All foreign keys must be named <table>_id where table is the name if the class mapped formated like said above."
.PD
.PP
You can overide those conventions at import time:
.PP
.Vb 5
\&    package My::Model;
\&    use Coat;
\&    use Coat::Persistent 
\&            table_name  => \*(Aqmymodel\*(Aq, # default would be \*(Aqmy_model\*(Aq
\&            primary_key => \*(Aqmid\*(Aq;     # default would be \*(Aqid\*(Aq
.Ve
.SS "\s-1ABOUT\s0 \s-1PRIMARY\s0 \s-1KEYS\s0"
.IX Subsection "ABOUT PRIMARY KEYS"
Even if your table does not have a primary key, you can still use a
Coat::Persistent model over it. You just have to tell Coat::Persistent that
this table/model doesn't have a primary key :
.PP
.Vb 1
\&   use Coat::Persistent primary_key => undef;
.Ve
.PP
Note that instances of such a model cannot be saved like regular ones: there's
no primary key, so it's impossible to build \s-1UPDATE\s0 \s-1SQL\s0 queries properly. That's
why you'll have to give a condition whenver you call \fIsave()\fR.
.PP
For the same reason, it's impossible to use \fIfind()\fR with numeric values (whi are
assumed to be primary key values).
.PP
Example :
    package Model;
    ...
    use Coat::Persistent primary_key => undef;
    ...
.PP
.Vb 1
\&    package  main;
\&
\&    my $obj = Model\->find(43); # FAIL : there\*(Aqs no primary key known for Model
\&    my $obj = Model\->find_by_some_attribute(25); # OK
\&
\&    $obj\->save(); # FAIL : the SQL query cannot be built without a primary key
\&                  # defined
\&
\&    $obj\->save({some_attribute => 25}); # OK
.Ve
.PP
Note that it's not recommended to use tables whithout primary keys, the support
is only provided to support existing/border\-line database schemas we can find
in real-world.
.PP
Use that feature with caution!
.SH "CONFIGURATION"
.IX Header "CONFIGURATION"
You have two options for setting a database handle to your class. Either you
already have a dbh an you set it to your class, or you don't and you let
Coat::Persistent initialize it.
.PP
If you already have a database handle, use Coat::Persistent\->set_dbh($dbh),
otherwise, use the \s-1DBI\s0 mapping explained below.
.PP
head2 \s-1ALREADY\s0 \s-1EXISTING\s0 \s-1DATABASE\s0 \s-1HANDLE\s0
.PP
You may want to tell Coat::Persistent to use a \f(CW$dbh\fR you already have in hands,
then you can use the \fIset_dbh()\fR method.
.IP "\fBset_dbh($dbh)\fR" 4
.IX Item "set_dbh($dbh)"
Set the given database handle for the calling class (set it by default if class
is Coat::Persistent).
.SS "\s-1DBI\s0 \s-1MAPPING\s0"
.IX Subsection "DBI MAPPING"
You have to tell Coat::Persistent how to map a class to a \s-1DBI\s0 driver. You can
either choose to define a default mapper (in most of the cases this is what
you want) or define a mapper for a specific class.
.PP
In order for your mapping to be possible, the driver you use must be known by
Coat::Persistent, you can modify its driver mapping matrix if needed.
.IP "\fBdrivers( )\fR" 4
.IX Item "drivers( )"
Return a hashref representing all the drivers mapped.
.Sp
.Vb 1
\&  MyClass\->drivers;
.Ve
.ie n .IP "\fBget_driver( \fB$name\fB )\fR" 4
.el .IP "\fBget_driver( \f(CB$name\fB )\fR" 4
.IX Item "get_driver( $name )"
Return the Perl module of the driver defined for the given driver name.
.Sp
.Vb 1
\&  MyClass\->get_driver( \*(Aqmysql\*(Aq );
.Ve
.ie n .IP "\fBadd_driver( \fB$name\fB, \f(BI$module\fB )\fR" 4
.el .IP "\fBadd_driver( \f(CB$name\fB, \f(CB$module\fB )\fR" 4
.IX Item "add_driver( $name, $module )"
Add or replace a driver mapping rule.
.Sp
.Vb 1
\&  MyClass\->add_driver( sqlite => \*(Aqdbi:SQLite\*(Aq );
.Ve
.PP
Then, you can use your driver in mapping rules. Basically, the mapping will
generate a \s-1DBI\-\s0>\fIconnect()\fR call.
.ie n .IP "\fBCoat::Persistent\->map_to_dbi \fB$driver\fB, \f(BI@options\fB \fR" 4
.el .IP "\fBCoat::Persistent\->map_to_dbi \f(CB$driver\fB, \f(CB@options\fB \fR" 4
.IX Item "Coat::Persistent->map_to_dbi $driver, @options "
This will set the default mapper. Every class that hasn't a specific mapper set
will use this one.
.ie n .IP "\fB_\|_PACKAGE_\|_\->map_to_dbi \fB$driver\fB, \f(BI@options\fB \fR" 4
.el .IP "\fB_\|_PACKAGE_\|_\->map_to_dbi \f(CB$driver\fB, \f(CB@options\fB \fR" 4
.IX Item "__PACKAGE__->map_to_dbi $driver, @options "
This will set a mapper for the current class.
.PP
Supported values for \fB\f(CB$driver\fB\fR are the following :
.ie n .IP "\fIcsv\fR : this will use \s-1DBI\s0's ""\s-1DBD:CSV\s0"" driver to map your instances to a \s-1CSV\s0 file. \fB\fB@options\fB\fR must contains a string as its first element being like the following: ""f_dir=<\s-1DIRECTORY\s0>"" where \s-1DIRECTORY\s0 is the directory where to store de \s-1CSV\s0 files." 4
.el .IP "\fIcsv\fR : this will use \s-1DBI\s0's ``\s-1DBD:CSV\s0'' driver to map your instances to a \s-1CSV\s0 file. \fB\f(CB@options\fB\fR must contains a string as its first element being like the following: ``f_dir=<\s-1DIRECTORY\s0>'' where \s-1DIRECTORY\s0 is the directory where to store de \s-1CSV\s0 files." 4
.IX Item "csv : this will use DBI's DBD:CSV driver to map your instances to a CSV file. @options must contains a string as its first element being like the following: f_dir=<DIRECTORY> where DIRECTORY is the directory where to store de CSV files."
Example:
.Sp
.Vb 3
\&    packahe Foo;
\&    use Coat::Persistent;
\&    _\|_PACKAGE_\|_\->map_to_dbi(\*(Aqcsv\*(Aq, \*(Aqf_dir=./t/csv\-directory\*(Aq);
.Ve
.ie n .IP "\fImysql\fR : this will use \s-1DBI\s0's ""dbi:mysql"" driver to map your instances to a MySQL database. \fB\fB@options\fB\fR must be a list that contains repectively: the database name, the database user, the database password." 4
.el .IP "\fImysql\fR : this will use \s-1DBI\s0's ``dbi:mysql'' driver to map your instances to a MySQL database. \fB\f(CB@options\fB\fR must be a list that contains repectively: the database name, the database user, the database password." 4
.IX Item "mysql : this will use DBI's dbi:mysql driver to map your instances to a MySQL database. @options must be a list that contains repectively: the database name, the database user, the database password."
Example:
.Sp
.Vb 3
\&    package Foo;
\&    use Coat::Persistent;
\&    _\|_PACKAGE_\|_\->map_to_dbi(\*(Aqmysql\*(Aq => \*(Aqdbname\*(Aq, \*(Aqdbuser\*(Aq, \*(Aqdbpass\*(Aq );
.Ve
.SS "\s-1MYSQL\s0 AUTO-INCREMENT \s-1FEATURE\s0"
.IX Subsection "MYSQL AUTO-INCREMENT FEATURE"
When using MySQL, you can choose either to let Coat::Persistent set itself 
primary key values for new entries, or use MySQL auto_increment mechanism.
.PP
This is done by calling Coat::Persistent\->\fIdisable_internal_sequence_engine()\fR;
before any call to \fImap_to_dbi()\fR or \fIset_dbh()\fR.
.PP
Currently, this is only tested to work with MySQL, patches for supporting 
other database engines are welcome.
.PP
Make sure you disable the internal sequence engine before initializing the \f(CW$dbh\fR,
otherwise the two tables needed by DBIx::Sequence will be created in your \s-1DB\s0 
(dbix_sequence_release and dbix_sequence_state).
.PP
A typical use of a MySQL database with auto_increment primary keys woudl like
the following:
.PP
.Vb 3
\&    # $dbh is an hanlde to a MySQL DB
\&    Coat::Persistent\->disable_internal_sequence_engine();
\&    Coat::Persistent\->set_dbh($dbh);
.Ve
.SS "\s-1CACHING\s0"
.IX Subsection "CACHING"
Since version 0.0_0.2, Coat::Persistent provides a simple way to cache the
results of underlying \s-1SQL\s0 requests. By default, no cache is performed.
.PP
You can either choose to enable the caching system for all the classes (global
cache) or for a specific class. You could also define different cache
configurations for each class.
.PP
When the cache is enabled, every \s-1SQL\s0 query generated by Coat::Persistent is
first looked through the cache collection. If the query is found, its cached
result is returned; if not, the query is executed with the appropriate \s-1DBI\s0
mapper and the result is cached.
.PP
The backend used by Coat::Persistent for caching is Cache::FastMmap which
is able to expire the data on his own. Coat::Persistent lets you access the
Cache::FastMmap object through a static accessor :
.IP "\fBCoat::Persistent\->cache\fR : return the default cache object" 4
.IX Item "Coat::Persistent->cache : return the default cache object"
.PD 0
.IP "\fB_\|_PACKAGE_\|_\->cache\fR : return the cache object for the class _\|_PACKAGE_\|_" 4
.IX Item "__PACKAGE__->cache : return the cache object for the class __PACKAGE__"
.PD
.PP
To set a global cache system, use the static method \fBenable_cache\fR. This
method receives a hash table with options to pass to the Cache::FastMmap
constructor.
.PP
Example :
.PP
.Vb 5
\&    Coat::Persistent\->enable_cache(
\&        expire_time => \*(Aq1h\*(Aq,
\&        cache_size  => \*(Aq50m\*(Aq,
\&        share_file  => \*(Aq/var/cache/myapp.cache\*(Aq,
\&    );
.Ve
.PP
It's possible to disable the cache system with the static method
\&\fBdisable_cache\fR.
.PP
See Cache::FastMmap for details about available constructor's options.
.SH "METHODS"
.IX Header "METHODS"
.SS "\s-1CLASS\s0 \s-1CONFIGURATION\s0"
.IX Subsection "CLASS CONFIGURATION"
The following pragma are provided to configure the mapping that will be 
done between a table and the class.
.ie n .IP "\fBhas_p \fB$name\fB => \f(BI%options\fB\fR" 4
.el .IP "\fBhas_p \f(CB$name\fB => \f(CB%options\fB\fR" 4
.IX Item "has_p $name => %options"
Coat::Persistent classes have the keyword \fBhas_p\fR to define persistent
attributes. Attributes declared with \fBhas_p\fR are valid Coat attributes and
take the same options as Coat's \fBhas\fR method. (Refer to Coat for details).
.Sp
All attributes declared with \fBhas_p\fR must exist in the mapped data backend
(they are a column of the table mapped to the class).
.ie n .IP "\fBhas_one \fB$class\fB\fR" 4
.el .IP "\fBhas_one \f(CB$class\fB\fR" 4
.IX Item "has_one $class"
Tells that current class owns a subobject of the class \f(CW$class\fR. This will allow
you to set and get a subobject transparently.
.Sp
The backend must have a foreign key to the table of \f(CW$class\fR.
.Sp
Example:
.Sp
.Vb 2
\&    package Foo;
\&    use Coat::Persistent;
\&
\&    has_one \*(AqBar\*(Aq;
\&
\&    package Bar;
\&    use Coat::Persistent;
\&
\&    my $foo = new Foo;
\&    $foo\->bar(new Bar);
.Ve
.ie n .IP "\fBhas_many \fB$class\fB\fR" 4
.el .IP "\fBhas_many \f(CB$class\fB\fR" 4
.IX Item "has_many $class"
This is the same as has_one but says that many items are bound to one
instance of the current class.
The backend of class \f(CW$class\fR must provide a foreign key to the current class.
.SS "\s-1CLASS\s0 \s-1METHODS\s0"
.IX Subsection "CLASS METHODS"
The following methods are inherited by Coat::Persistent classes, they provide
features for accessing and touching the database below the abstraction layer.
Those methods must be called in class-context.
.IP "\fIFind by id\fR: This can either be a specific id or a list of ids (1, 5, 6)" 4
.IX Item "Find by id: This can either be a specific id or a list of ids (1, 5, 6)"
.PD 0
.IP "\fIFind in scalar context\fR: This will return the first record matched by the options used. These options can either be specific conditions or merely an order. If no record can be matched, undef is returned." 4
.IX Item "Find in scalar context: This will return the first record matched by the options used. These options can either be specific conditions or merely an order. If no record can be matched, undef is returned."
.IP "\fIFind in list context\fR: This will return all the records matched by the options used. If no records are found, an empty array is returned." 4
.IX Item "Find in list context: This will return all the records matched by the options used. If no records are found, an empty array is returned."
.PD
.PP
The following options are supported :
.IP "\fBselect\fR: By default, this is * as in \s-1SELECT\s0 * \s-1FROM\s0, but can be changed." 4
.IX Item "select: By default, this is * as in SELECT * FROM, but can be changed."
.PD 0
.IP "\fBfrom\fR: By default, this is the table name of the class, but can be changed to an alternate table name (or even the name of a database view)." 4
.IX Item "from: By default, this is the table name of the class, but can be changed to an alternate table name (or even the name of a database view)."
.ie n .IP "\fBorder\fR: An \s-1SQL\s0 fragment like ""created_at \s-1DESC\s0, name""." 4
.el .IP "\fBorder\fR: An \s-1SQL\s0 fragment like ``created_at \s-1DESC\s0, name''." 4
.IX Item "order: An SQL fragment like created_at DESC, name."
.IP "\fBgroup\fR: An attribute name by which the result should be grouped. Uses the \s-1GROUP\s0 \s-1BY\s0 SQL-clause." 4
.IX Item "group: An attribute name by which the result should be grouped. Uses the GROUP BY SQL-clause."
.IP "\fBlimit\fR: An integer determining the limit on the number of rows that should be returned." 4
.IX Item "limit: An integer determining the limit on the number of rows that should be returned."
.PD
.PP
Examples without options:
.PP
.Vb 4
\&    my $obj = Class\->find(23);
\&    my @list = Class\->find(1, 23, 34, 54);
\&    my $obj = Class\->find("field = \*(Aqvalue\*(Aq");
\&    my $obj = Class\->find(["field = ?", $value]);
.Ve
.PP
Example with options:
.PP
.Vb 1
\&    my @list = Class\->find($condition, { order => \*(Aqfield1 desc\*(Aq })
.Ve
.ie n .IP "\fBfind_by_sql($sql, \fB@bind_values\fB\fR" 4
.el .IP "\fBfind_by_sql($sql, \f(CB@bind_values\fB\fR" 4
.IX Item "find_by_sql($sql, @bind_values"
Executes a custom sql query against your database and returns all the results
if in list context, only the first one if in scalar context.
.Sp
If you call a complicated \s-1SQL\s0 query which spans multiple tables the columns
specified by the \s-1SELECT\s0 that aren't real attributes of your model will be
provided in the hashref of the object, but you won't have accessors.
.Sp
The sql parameter is a full sql query as a string. It will be called as is,
there will be no database agnostic conversions performed. This should be a
last resort because using, for example, MySQL specific terms will lock you to
using that particular database engine or require you to change your call if
you switch engines.
.Sp
Example:
.Sp
.Vb 2
\&    my $obj = Class\->find_by_sql("select * from class where $cond");
\&    my @obj = Class\->find_by_sql("select * from class where col = ?", 34);
.Ve
.IP "\fBcreate\fR" 4
.IX Item "create"
Creates an object (or multiple objects) and saves it to the database.
.Sp
The attributes parameter can be either be a hash or an array of hash-refs. These
hashes describe the attributes on the objects that are to be created.
.Sp
Examples
.Sp
.Vb 2
\&  # Create a single new object
\&  User\->create(first_name => \*(AqJamie\*(Aq)
\&  
\&  # Create an Array of new objects
\&  User\->create([{ first_name => \*(AqJamie\*(Aq}, { first_name => \*(AqJeremy\*(Aq }])
.Ve
.SS "\s-1INSTANCE\s0 \s-1METHODS\s0"
.IX Subsection "INSTANCE METHODS"
The following methods are provided by objects created from the class.
Those methods must be called in instance-context.
.IP "\fBsave\fR" 4
.IX Item "save"
If no record exists, creates a new record with values matching those of the
object attributes.
If a record does exist, updates the record with values matching those
of the object attributes.
.Sp
Returns the id of the object saved.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
See Coat for all the meta-class documentation. See Cache::FastMmap for
details about the cache objects provided.
.SH "AUTHOR"
.IX Header "AUTHOR"
This module was written by Alexis Sukrieh <sukria@cpan.org>.
Quite everything implemented in this module was inspired from
ActiveRecord::Base's \s-1API\s0 (from Ruby on Rails).
.PP
Parts of the documentation are also taken from ActiveRecord::Base when
appropriate.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2007 by Alexis Sukrieh.
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Hey! \fBThe above document had some coding errors, which are explained below:\fR
.IP "Around line 1212:" 4
.IX Item "Around line 1212:"
=back without =over
.IP "Around line 1214:" 4
.IX Item "Around line 1214:"
\&'=item' outside of any '=over'
